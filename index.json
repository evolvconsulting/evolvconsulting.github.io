[{"content":"Let’s talk about YAML pipelines in Azure DevOps. YAML pipelines are great! Using YAML pipelines in Azure DevOps allows deployment pipelines to be expressed as code. Expressing pipelines as code simplifies the use of version control to support build \u0026amp; release pipelines. It also allows DevOps professionals to create libraries of pipeline code that can be reused to accelerate new tasks. All of this is great, but it is also important to ensure that pipelines are secure. One approach to securing a pipeline is to set a clear separation of responsibilities between those who write the code and those who manage the resources that deploy and execute the code. In some industries this may be more than a best practice; it may be a requirement.\nToday we’re going to walk through the implementation of a pattern that can be leveraged to build a secure environment that encourages collaboration and cross-training. We\u0026rsquo;ll use a small project to provide context and direct our implementation.\nCore Concepts There are a few core concepts that we\u0026rsquo;ll be working with to implement our pattern. These Azure DevOps features will allow us to secure resources when using YAML templates.\nApprovals and Checks A service connection is what allows Azure DevOps (ADO) to securely connect to external resources such as the Azure Resource Manager, Kubernetes, etc. It is possible to add all sorts of conditions around the use of a service connection. These are known as Approvals \u0026amp; Checks. We will be using Approvals and Required Templates as part of our project.  Note: It is possible to use Approvals \u0026amp; Checks with other resources such as Environments.\n Extended Templates An \u0026ldquo;extends\u0026rdquo; template has at least two components. The first component is a \u0026ldquo;root\u0026rdquo; template. This is typically the YAML pipeline that triggers the build/deploy. The second component is the \u0026ldquo;extends\u0026rdquo; template. The \u0026ldquo;extends\u0026rdquo; template augments the behavior of the \u0026ldquo;root\u0026rdquo; template by defining the entire flow or modifying the flow specified by the \u0026ldquo;root\u0026rdquo;.\nShared Connections The last feature our project will leverage is the ability to share service connections between projects. This allows us to define and manage all service connections in one place. Service connections can be created in the devops-core repository and then shared with the demo repository. The permissions and requirements of the service connection are enforced even when the connection is shared.\nThe Project We are going to create a new DevOps environment that uses secured YAML pipelines for both build and deploy operations. We also have our first customer: a development team that would like to deploy a shiny new Azure Container Registry! We need to ensure the following:\n The development team may create a deployment template The development team may manage the pipeline triggers The development team must obtain approvals for deployments The development team must use a predefined build \u0026amp; release pipeline.  At the end of the project the development team will be able to deploy a container registry using a secured devops implementation. The templates used in this project can be found on github.\nArchitecture Overview Our \u0026ldquo;separation of concerns\u0026rdquo; pattern uses a secure project that is owned and maintained by the DevOps team. We\u0026rsquo;ll name this project devops-core. The devops-core project will be home to service connections, pipeline templates and the IaC needed to maintain and run the pipeline infrastructure. We\u0026rsquo;ll go into each of these later as we build them out and secure them.\nAdditional projects are created for other development teams. Members of development teams may view the contents of the devops-core project (minus secret things) but are unable to make changes to devops-core resources without obtaining approvals from the DevOps team.  Fig 1: Architecture Overview   Implementation We\u0026rsquo;ll start the implementation by creating and configuring our devops-core project and all of its dependencies. After that we\u0026rsquo;ll build out a demo project for our development team. We will then create a little bicep template and a YAML pipeline to deploy the project.\nThis guide makes the following assumptions:\n You\u0026rsquo;ve already got an Azure Subscription. You\u0026rsquo;ve already got an Azure DevOps Organization.  Organization Setup Let\u0026rsquo;s create two groups: devops-core and demo.\n Sign into Azure DevOps (ADO) Navigate to \u0026lsquo;Organization\u0026rsquo; settings in the lower left corner. Under \u0026lsquo;Security\u0026rsquo; choose \u0026lsquo;Permissions\u0026rsquo;. Create two groups: devops-core and demo   New ADO Permission Groups   Project: devops-core Create the Project Now that we have the two groups setup we can create the devops-core project. This step is pretty easy - just navigate back to the organization page and click the \u0026ldquo;+ New Project\u0026rdquo; button in the upper-right.\n New ADO Project   Group Permissions Head back to the Organization settings and update the permissions of those two groups created previously.\n Add the devops-core group as a member to [devops-core]/Project Administrators Add the demo group as a member to [devops-core]/Readers  Create a Service Connection The next thing we\u0026rsquo;ll do is create a service connection. The process is pretty well documented in the \u0026ldquo;Manage Service Connections\u0026rdquo; page found in the ADO docs.  New Service Connection   For the purpose of this project we\u0026rsquo;ll create a service connection named devopscore-arm-dev. The devopscore-arm-dev connection will be an ARM connection that has contributor access to a dev subscription.\n Note: In practice it is a good idea to develop a strategy for limiting the scope of a service connection.\n Create Pipeline Repo We will create one repository named pipeline. This repository will contain pipeline templates that will be extended by root templates in other repositories.\npipeline folder layout\n. ├── entry-point │ └── bicep-deployment.yml └── README.md \nThe entry-point folder contains our \u0026ldquo;extends\u0026rdquo; templates. These are the templates that will be called by other pipeline templates. Our service connections will require that an approved \u0026ldquo;extends\u0026rdquo; template is used. The bicep-deployment.yml is the \u0026ldquo;extends\u0026rdquo; template that will be used by our project. There is quite a lot that can be done with extended templates but for our purpose we will keep it simple and use the extended template to define the flow for building and deploying a bicep template. Any \u0026ldquo;root\u0026rdquo; templates that extend the bicep-deployment.yml will supply parameters and hand over control the the \u0026ldquo;extends\u0026rdquo; template.\nGo ahead and create the directory structure noted above. The contents of bicep-deployment.yml are available on github. We\u0026rsquo;ll talk through some of the YAML next.\nExcerpt: bicep-deployment.yml\nparameters: - name: bicepPath type: string - name: targetRg type: string variables: ... - name: armServiceConn ${{ if eq(variables[\u0026#39;System.TeamProject\u0026#39;], \u0026#39;devops-core\u0026#39;) }}: value: devopscore-arm-dev ${{ if ne(variables[\u0026#39;System.TeamProject\u0026#39;], \u0026#39;devops-core\u0026#39;) }}: value: devopscore-arm-dev-$(System.TeamProject) - name: rgLocation value: centralus stages: ... \nLet\u0026rsquo;s take a closer look at a few lines of this YAML pipeline. parameters\nparameters: - name: bicepPath type: string - name: targetRg type: string These parameters will be supplied by the root template. They\u0026rsquo;ll be used within the pipeline to generate a resource group and also determine the path of the bicep template.\nService Connection\nvariables: ... - name: armServiceConn ${{ if eq(variables[\u0026#39;System.TeamProject\u0026#39;], \u0026#39;devops-core\u0026#39;) }}: value: devopscore-arm-dev ${{ if ne(variables[\u0026#39;System.TeamProject\u0026#39;], \u0026#39;devops-core\u0026#39;) }}: value: devopscore-arm-dev-$(System.TeamProject) The name that a pipeline uses to access a service connection depends on the execution context of the original or \u0026ldquo;root\u0026rdquo; pipeline. If the context of the executing pipeline is the same as the shared connection then the project name is appended to the service connection name. If the context of the executing pipeline is the same as the service connection, ie. devops-core, then the name of the service connection is unchanged. The conditional insertion allows us to render the correct connection name when the pipeline runs.\nAdd Checks \u0026amp; Approvals The service connection created previously has the ability to manage resources in Azure. These next steps will place restrictions on the use of the service connection. We will create two restrictions:\n An \u0026ldquo;approval\u0026rdquo; check that will require that a member of the DevOps team provide an approval at deploy time. A \u0026ldquo;required template\u0026rdquo; check that will require the \u0026ldquo;root\u0026rdquo; pipeline template extend our \u0026ldquo;bicep-deployment.yml\u0026rdquo; template.   NOTE Approvers may be anyone within the organization.\n Approval\n Navigate to the service connection and select \u0026ldquo;Approvals and Checks\u0026rdquo; from the vertical ellipse menu. From the next screen select the \u0026ldquo;Add Check\u0026rdquo; button. Choose the option for \u0026ldquo;Approvals\u0026rdquo; Add the \u0026lsquo;devops-core\u0026rsquo; group to the list of approvers.   Approvals   Required Template\n Navigate to the service connection and select \u0026ldquo;Approvals and Checks\u0026rdquo; from the vertical ellipse menu. From the next screen select the \u0026ldquo;Add Check\u0026rdquo; button. Choose the option for \u0026ldquo;Required Template\u0026rdquo;. Supply the repository information.   Required Template   Project: demo Now we need a project for our development team. Let\u0026rsquo;s call this project demo and create it in the same organization as our devops-core project. The demo project will contain the Bicep templates that the development team will use to deploy the Azure Container Registry.\nGroup Permissions Head back to the Organization settings and update the permissions for the devops-core and demo groups.\n Add the devops-core group as a member to [demo]/Project Administrators Add the demo group as a member to [demo]/Contributors  Share the Service Connection Before we can create a pipeline that uses the ARM service connection that was created in the devops-core project we need to share that service connection with the infra project. This is done in the \u0026ldquo;project settings\u0026rdquo; of the \u0026ldquo;devops-core\u0026rdquo; project. Once there, locate and select the service connection that we want to share (devopscore-arm-dev). From the vertical ellipse chose \u0026ldquo;Security\u0026rdquo;. At the bottom of the page you\u0026rsquo;ll find \u0026ldquo;Project Permissions\u0026rdquo;.  Project Permissions   This will allow pipelines in the demo project to use the devopscore-arm-dev service connection.\nCreate an Infra Repo Now that we have setup some global permissions for the project we need to add a repository for our developers to store their IaC. Let\u0026rsquo;s call the repository infra and create the initial directory structure shown below.\ninfra folder layout\n. └─── container-registry ├─── parameters │ ├─── dev.parameters.json | └─── main.parameters.json ├─── azure-pipelines.yml └─── main.bicep \nThe main.bicep file will contain a basic Bicep template that can be used to deploy a container registry. The parameter files are used to supply environment overrides (dev) and defaults (main). The azure-pipelines.yml is our \u0026ldquo;root\u0026rdquo; template.\nThe azure-devops.yml is our \u0026ldquo;root\u0026rdquo; pipeline template. This template will be extended by referencing our \u0026ldquo;extends\u0026rdquo; template (bicep-deploy.yml).\nazure-pipelines.yml\nresources: repositories: - repository: core type: git name: devops-core/pipeline ref: main extends: template: entry-point/bicep-deployment.yml@core parameters: bicepPath: container-registry targetRg: demo The azure-pipelines.yml is pretty simple. This is because it is only responsible for triggering builds and calling the extended template. The \u0026ldquo;resources\u0026rdquo; section allows us to reference the devops-core/pipeline repository. We are able to reference the \u0026ldquo;extends\u0026rdquo; template by using the \u0026ldquo;extends\u0026rdquo; attribute and adding template: entry-point/bicep-deployment.yml@core.   bicep-pipeline.yml\n azure-pipelines.yml\n      parameters: - name: bicepPath type: string - name: targetRg type: string    extends: template: entry-point/bicep-deployment.yml@core parameters: bicepPath: container-registry targetRg: demo      To see how the two templates interact compare the \u0026ldquo;parameters\u0026rdquo; section of the bicep-pipeline.yml to the \u0026ldquo;extends\u0026rdquo; section of the azure-pipelines.yml. The \u0026ldquo;template\u0026rdquo; attribute indicates the \u0026ldquo;extends\u0026rdquo; template that our \u0026ldquo;root\u0026rdquo; template will implement. The parameters defined in the bicep-pipeline.yml are supplied by the azure-pipelines.yml document. This allows the development team to supply some configuration details.\nPipeline As we\u0026rsquo;ve seen so far, the actual pipeline definition is created by two different files: a \u0026ldquo;root\u0026rdquo; template and an \u0026ldquo;extends\u0026rdquo; template. Let\u0026rsquo;s instantiate our pipeline.  Go to the demo project and navigate to \u0026ldquo;Pipelines\u0026rdquo; Select \u0026lsquo;New Pipeline\u0026rsquo; Choose \u0026lsquo;Azure Repos Git\u0026rsquo; as the location of the code Select the infra repository Finally, choose \u0026lsquo;Existing Azure Pipelines YAML file\u0026rsquo; and then supply the location of the azure-pipelines.yml file. Optionally, rename the pipeline. This will allow us to reuse the same repository for multiple infra projects and pipelines.  Pipeline Execution Let\u0026rsquo;s try executing the pipeline. On the first execution you\u0026rsquo;ll be prompted to provide the pipeline with permissions to access external resources such as the service connection. This will only occur the first time that each new resource is accessed by the pipeline. There\u0026rsquo;s a lot of information to explore on the summary page.\n Pipeline Execution     The \u0026ldquo;Sources\u0026rdquo; section shows two repositories. These include the repository that contains the \u0026ldquo;root\u0026rdquo; template as well as the repository that contains the \u0026ldquo;extends\u0026rdquo; template.\n Pipeline: Sources     The \u0026lsquo;Dev\u0026rsquo; stage has passed one check but it is waiting on another. Clicking on the \u0026ldquo;Review\u0026rdquo; button or clicking on the link in the stage tile will show the approval and check details. The pipeline has passed the \u0026ldquo;Required Template\u0026rdquo; check but it is still waiting on an approval. Clicking \u0026ldquo;approve\u0026rdquo; will allow the pipeline to proceed to completion.\n              Additional deployment stages, such as \u0026ldquo;test\u0026rdquo; and \u0026ldquo;production\u0026rdquo; can be created by adding additional service connections and updating the templates to include additional deployment stages that use the new connections. The connections can be secured in the same manner as the dev connection and different approvers can be specified for each environment.\nSummary That\u0026rsquo;s pretty much it. In a nut-shell we can secure our pipelines by drawing clear boundaries around responsibilities: develop and deploy. This separation can be achieved in Azure DevOps by creating a project for the devops team and requiring that all release pipelines use curated \u0026ldquo;extends\u0026rdquo; templates that are developed/approved by the responsible teams. Maintaining service connections in one place makes the connections easier to manage and easier to secure.\n","permalink":"https://evolvconsulting.github.io/posts/jkososki/ado-secure-yaml/","summary":"Let’s talk about YAML pipelines in Azure DevOps. YAML pipelines are great! Using YAML pipelines in Azure DevOps allows deployment pipelines to be expressed as code. Expressing pipelines as code simplifies the use of version control to support build \u0026amp; release pipelines. It also allows DevOps professionals to create libraries of pipeline code that can be reused to accelerate new tasks. All of this is great, but it is also important to ensure that pipelines are secure.","title":"Secure YAML Pipelines in Azure Dev Ops"},{"content":"","permalink":"https://evolvconsulting.github.io/posts/jkososki/readme/","summary":"","title":""}]